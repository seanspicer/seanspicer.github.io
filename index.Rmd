---
title       : Developing Data Products Course Project
subtitle    : Determining Anelastic Rock Attenuation
author      : Sean Spicer (sean.spicer@gmail.com)
job         : 
framework   : io2012        # {io2012, html5slides, shower, dzslides, ...}
highlighter : highlight.js  # {highlight.js, prettify, highlight}
hitheme     : tomorrow      # 
widgets     : [mathjax]            # {mathjax, quiz, bootstrap}
mode        : selfcontained # {standalone, draft}
knit        : slidify::knit2slides
---

## Motivation for the App

I work in the field of borehole seismic monitoring.  This involves placing array 3-Component Geophones in deep boreholes near 
seismically active areas.  In particular, this technique is used to monitor very small changes in stress that result 
from hydraluic stimulation (commonly known as Fracing).  These changes in stress create very small seismic events which 
can be recorded and located (mapped) using sophisticaed time-migration algorithms.  One of the challenges, however, is that the size of the event must be corrected for rock attenuation as the waves generated by the event travel through the earth.  In order
to determine this attenuation, we need 3 things:

1. Dominant Frequency of the Event
2. Average Velocity of the Rock
3. Q, the Seismic Quality Factor

This app allows us to adjust these three variables to optimally determine Q.

--- .class #id 

## The Science of Q

In reflection seismology, the anelastic attenuation factor, often expressed as seismic quality factor or 
      Q (which is inversely proportional to attenuation factor), quantifies the effects of anelastic attenuation 
      on the seismic wavelet caused by fluid movement and grain boundary friction. As a seismic wave propagates 
      through a medium, the elastic energy associated with the wave is gradually absorbed by the medium, eventually 
      ending up as heat energy. This is known as absorption (or anelastic attenuation) and will eventually cause 
      the total disappearance of the seismic wave.

The seismic Quality Factor, Q, is defined as: 

$$Q = 2{\pi}\left ( \frac{E}{{\delta}E} \right )$$

where $\frac{E}{{\delta}E}$ is the fraction of energy lost per cycle.

--- .class #id 

## Implementation

In practice, borehole measurements do not yield sufficiently accurate measurements to determine the Dominant Frequency nor the 
Average Rock Velocity of the near wellbore environment.  Therefore, in order to determine Q, one must adjust these 
values in addition to Q, in order to flatten the scaled amplitudes - thereby removing effects of rock attenuation and spherical dispersion with distance.


The code we use to translate from raw to scaled amplitudes is:

```{r, eval=FALSE}

      # Correct for Q and spherical spreading
      amps$sphSpreadRemoved = amps$rms_signal.p*amps$DistToGeophone;
      amps$coef = (input$avgFrq * pi) / (input$qval * input$avgVel);
      amps$corAmp = amps$sphSpreadRemoved*exp(amps$coef*amps$DistToGeophone);
```

Rather than "Hunt-and-Peck", the app allows a user to adjust these factors interactively.

--- .class #id 

## Example
Q = 52, Average Velocity = 13,500 (ft/sec), Average Frequency = 130 Hz

```{r, eval=TRUE, echo=FALSE, warning=FALSE, fig.width=13}
      
require(gridExtra);
      
amps = read.table("D:/work/datascience/DevelopingDataProducts/AmpsByPod.csv", sep=",", header = T);

amps$well = "Tmp";

for(i in 1:nrow(amps)) {
  
  if(amps$pod_num[i] <= 40)
  {
    amps$well[i] = "Deep";
  }
  else
  {
    amps$well[i] = "Shallow";
  }
  
}

qval = 52;
avgVel = 13500;
avgFrq = 130;

p1 <- ggplot(amps[amps$well == 'Deep',]) + 
    geom_point(aes(x=DistToGeophone, y=rms_signal.p)) + 
    xlab('Distance to Geophone') +
    ylab('Recorded Signal (microvolts)') +
    ggtitle('Uncorrected Amplitudes') +
    scale_y_log10();

    # Correct for Q and spherical spreading
    amps$sphSpreadRemoved = amps$rms_signal.p*amps$DistToGeophone;
    amps$coef = (avgFrq * pi) / (qval * avgVel);
    amps$corAmp = amps$sphSpreadRemoved*exp(amps$coef*amps$DistToGeophone);
    
    # Find the best fit line
    fit <- lm(log(amps$corAmp) ~ amps$DistToGeophone);
    amps$vals <- exp(predict(fit, list(amps$DistToGeohpone)));
    
p2 <- ggplot(amps[amps$well == 'Deep',]) + 
      geom_point(aes(x=DistToGeophone, y=corAmp)) + 
      geom_line(aes(x=DistToGeophone, y=vals), color="Red", size=2) + 
      xlab('Distance to Geophone') +
      ylab('Scaled Amplitude') +
      ggtitle('Corrected Amplitudes') +
      scale_y_log10();

grid.arrange(p1, p2, ncol=2);
         
```

